---
layout: post
title: Orbz
subtitle: ScoreJam 12
cover-img: /assets/img/orbzbanner.png
thumbnail-img: /assets/img/OrbzLogo.jpg
share-img: /assets/img/OrbzLogo.jpg
tags: [rhythm, shooter, 3d, Wwise, Unity, C#]
---

Orbz was my second game jam game, where I chose to work in a smaller team to have more control over the codebase. This game is a 3D rhythm-based aim trainer game whereby score is gained by consecutively hitting targets; the score would then be multiplied if the player managed to combine two primary colours (comparing the cursor colour and the target's colour), to match the target box colour.

| Theme | Team Size | Jam Duration | Role | Engine |
| :---- |:--------- | :----------- | :--- | :----- |
| Combination | Two | 72 hours | Programmer | Unity/C# |

<hr class="medium">
<iframe width="560" height="315" src="https://www.youtube.com/embed/vdA9hRD357I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="mx-auto d-block"></iframe>

### Objectives

In this Jam I wanted to address some of the shortcomings from the previous project, but also attempt to do some new techniques:

* Maintain a clear git tree
* Plan the **architecture** in advance
* **Wwise/Unity** integrations
* Have a release ready build the day before the deadline to allow for polish
* Smaller scope

<img class="mx-auto d-block" src="/assets/img/orbzmenu.png" style="border-radius: 50%;" />

### Responsibilities

As the sole programmer in this team, my responsibilities were many:
* Ensure all the functionality is implemented well in advance of the deadline
* Maintain the github repository
* Implement the scoreboard functionality required for the game jam
* Ensure the Wwise integration works correctly
* Implement the UI

### Personal Highlights

![Modulation](/assets/img/OrbzMod.gif){: .mx-auto.d-block :}

#### Modulation & Wwise Callbacks

I wanted to express my audio designers talents in game, and his tool of choice was WWise. A bit of time with the **Wwise API** resulted in this:
```cs
    void Update()
    {
        int type = 1;
        float value;

        AkSoundEngine.GetRTPCValue("Modulation", gameObject, 0, out value, ref type);

        // Scaling the value down and smoothing the value a little for visual representation
        value = scaleMultiplier * (value + 48) / 48;
        value = Mathf.Round(value * 1000f) / 1000f;
        value = Mathf.Pow(value, 2);

        // Setting the scale ~
        transform.localScale = Vector3.Lerp(transform.localScale, new Vector3(value, value, value), (Time.deltaTime * smoothingMultiplier));
    }
```
The primary purpose was to produce a visual equaliser-like effect within the game world. This idea lead our game design, as we intended to give the player a better score based on the local scale of the **modulating** objects (more point if you can hit the smaller target).

<hr class="medium">
<img class="mx-auto d-block" src="/assets/img/scoreboard.png" style="border-radius: 50%;" />

#### Local Integrity Checks

As part of the game jam, we were asked to created a **scoreboard** feature. We went with a local scoreboard feature since the game was intended to be posted for play after the end of the jam, and we didn't want to maintain a scoreboard API for years to come. 

One of the issues with a local scoreboard however is score tampering, especially because a competition would be held in the second half of the game jam. Allowing streamers to post their scores. It was integral to have some form of score checking to ensure the locally stored scoreboard wasn't tampered with by potential competitors. My (albeit simple) solution was as follows:

```cs
        // A struct was created seperately to contain the username, score and the hash.
        // This code handles the creation of the hash and the integrity check

        // Fairly straightforward function, this code takes the scoreboard data and returns a new version
        // now with 100% more hash!
        private ScoreboardEntryData CreateIntegrityHash(ScoreboardEntryData scoreboardEntryData)
        {
            string combinedValues = scoreboardEntryData.entryName + scoreboardEntryData.entryScore.ToString();
            scoreboardEntryData.entryHash = HashString(combinedValues);
            return scoreboardEntryData;
        }

        // Standard SHA256 generation function
        private string HashString(string stringToHash)
        {
            using (SHA256 sha256Hash = SHA256.Create())
            {
                byte[] data = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(stringToHash));
                var sBuilder = new StringBuilder();

                for (int i = 0; i < data.Length; i++)
                {
                    sBuilder.Append(data[i].ToString("x2"));
                }

                return sBuilder.ToString();
            }
        }


        // This function checks the provided score to ensure the generated sha256 hash
        // matches the one stored in the provided struct
        //
        // If not I set the values to make it obvious the player is likely cheating which would
        // be obvious during score submission in the jam.
        //
        // (Ideally we'd just remove the score, but this makes it easier to determine if anyone has tried to cheat)
        private ScoreboardEntryData CheckHighScore(ScoreboardEntryData highscore)
        {
            string combinedValues = highscore.entryName + highscore.entryScore.ToString();
            string hashedString = HashString(combinedValues);

            if (highscore.entryHash != hashedString)
            {
                highscore.entryName = "1337Haxx0r";
                highscore.entryScore = 0;
                highscore.entryHash = HashString(highscore.entryName + highscore.entryScore.ToString());
            }

            return highscore;

        }
```
This was an interesting challenge but it was nice to be able to actually code some of the functions I spend my time with during my day job. With that said, this isn't the most secure method to store and check an integrity hash, but with such a limited time-frame I needed to move onto developing the rest of the game.

### Project Takeaways

<img class="mx-auto d-block" src="/assets/img/orbz.png" style="border-radius: 50%;" />

#### Wwise

Although I was able to get the hang of the Wwise API to some degree, there is still much more to learn there and that's just the API. The software as well has a huge array of features that could be used in future games. I was keen to make good use of my Audio Designer's skills, but to work the audio neatly into the game also needed my skills to be equally as impressive. Additionally I'm looking forward to when Wwise works alongside WedGL builds!

#### Online vs. Offline Data Storage

When considering the options for the scoreboard, I had to debate my options regarding how I wanted to display my scoreboard.

For example, the API provided by the jam was happy to handle the storage of data and used secret keys to ensure the **integrity** of the data, but it wasn't using **HTTPS** so now **transport security** was a concern! Then the alternative was to create my own API, which would take further development time and maintaining it would require upkeep on my part.

These are all fascinating problems and I really enjoyed working out a solution amongst these issues.

#### Maths Considerations

Due to the way in with I applied score multipliers, I was required to use unsigned longs to store the score. If I were to use an online API to store the score I would have to check the make sure my game didn't break the API's limits with the sheer size of the scores alone. In future I need to consider the potential end-goal of the project to determine if I really need to use a certain data type, or if a design decision can be made to avoid potential errors.


